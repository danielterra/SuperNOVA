## Problem 1: Database Technology Selection

### What
We don't know which database technology to use for SuperNOVA's immutable, reactive data model that needs to:
- Work across desktop platforms (Linux, Windows, macOS)
- Support immutable data patterns (append-only, no updates/deletes)
- Expose changes as observable events (for reactive actions)
- Provide good performance for user-facing operations (<100ms for common queries)
- Be embeddable (no separate server process)
- Support efficient export/import of data subsets (foundation for sync layer)

### Why
The database is foundational to achieving KR1. Users need to record 20+ transactions quickly (<30 minutes), which requires:
- Fast data entry and retrieval
- Reliable local storage
- Observable changes (for reactive features in KR2)

Choosing the wrong technology could:
- Block cross-platform development
- Make immutability and reactivity difficult to implement
- Create performance bottlenecks
- Force a costly rewrite later

### How (Hypotheses)

#### Option 1: SurrealDB (with RocksDB backend) ⭐ RECOMMENDED
**Pros:**
- **Native change observability** - Live Queries + Change Feeds (perfect for reactive architecture)
- Cross-platform (Linux, Windows, macOS, and future iOS support)
- Embeddable in Rust applications
- Multi-model flexibility (document, graph, key-value)
- Versioning support via SurrealKV (time-travel queries when mature)
- Pure Rust (memory safe, good FFI)

**Cons:**
- Younger project (v2.0 recently released, moderate risk)
- SurrealKV still evolving (use RocksDB backend initially)
- Must implement immutability at application level
- Larger footprint than pure key-value stores

**Performance:** Meets all requirements (<1s for 100 inserts, <50ms queries)

#### Option 2: redb + Custom Observability Layer
**Pros:**
- Stable 1.0 release with file format guarantees
- **Excellent individual write performance** (920ms for 100 records)
- Pure Rust (memory safe, no C++ dependencies)
- Small footprint, clean codebase
- ACID transactions with MVCC
- Only 9 open issues (very stable)

**Cons:**
- **No built-in change observability** (must implement observer pattern manually)
- Key-value only (must build data model on top)
- Must implement immutability patterns at application level
- Slower batch writes vs LSM trees

**Performance:** Best for individual transaction inserts

#### Option 3: RocksDB (via rust-rocksdb)
**Pros:**
- Battle-tested at massive scale (Facebook, Apple, FoundationDB)
- **Excellent batch write performance** (451ms)
- Transaction Log Iterator for change tracking
- EventListener API for monitoring
- Rich tuning options

**Cons:**
- C++ dependency (slower builds, external dependencies)
- Change observability less elegant than SurrealDB
- Requires significant tuning for optimal performance
- Higher memory usage during compaction

**Performance:** Best for bulk operations

#### Option 4: SQLite + Event Store Pattern (Conservative baseline)
**Pros:**
- Universal platform support (25+ years of stability)
- Most deployed database in the world
- Excellent tooling ecosystem
- Well-understood technology

**Cons:**
- **Poor change observability** (requires polling or complex triggers)
- Must implement event store pattern manually
- Not designed for reactive architectures
- Schema migrations can be painful

**Performance:** Good enough, but not optimized for reactivity

### Success Criteria

The chosen database technology must demonstrate:

1. **Cross-platform viability** - Works on Linux, Windows, and macOS
2. **Immutability support** - Can enforce append-only operations efficiently
3. **Performance baseline** - Can handle:
   - Insert 100 transaction records in <1 second
   - Query current state (20 transactions) in <50ms
   - Query history (100 records) in <200ms
4. **Change observability** - Can efficiently notify when data changes (for reactive actions)
5. **Export/Import** - Can efficiently export subsets of data (for sync layer to use)
6. **Development speed** - Doesn't block rapid prototyping for Q1 goals

### Validation Plan

1. **Research phase** (3 days) ✅ COMPLETE
   - Comprehensive evaluation of embedded databases
   - SurrealDB identified as best fit for reactive architecture
   - redb as stable fallback option
   - Performance benchmarks reviewed

2. **Prototype phase** (5 days)
   - **Prototype A: SurrealDB** (2 days)
     - Implement basic Transaction entity with CRUD
     - Test Live Queries for change notifications
     - Verify cross-platform build (Linux, Windows, macOS)
     - Benchmark insert/query performance

   - **Prototype B: redb + Custom Observer** (2 days)
     - Implement basic Transaction entity with CRUD
     - Build simple observer pattern for change notifications
     - Verify cross-platform build
     - Benchmark insert/query performance

   - **Comparison** (1 day)
     - Developer experience (ease of implementation)
     - Performance (actual vs expected)
     - Code complexity (lines of code, maintainability)
     - Risk assessment (maturity, community, documentation)

3. **Decision** (1 day)
   - Select primary option based on prototype results
   - Document decision rationale and trade-offs
   - Create risk mitigation plan
   - Identify any blocking issues discovered

**Total time budget: 2 weeks maximum**

### Recommendation

Start prototyping with **SurrealDB** as Option 1 due to:
- Native change observability (critical for reactive architecture)
- Best alignment with SuperNOVA principles
- Cross-platform support including future mobile

Have **redb** ready as fallback if SurrealDB proves too immature or complex.

---

## ✅ DECISION (2025-10-29)

**Selected: SurrealDB with RocksDB backend**

**Rationale:**

1. **Change Observability** - Live Queries and Change Feeds are native features, perfect for SuperNOVA's reactive architecture (Principle 4: Total Reactivity)

2. **Minimal Dependencies** - Pure Rust implementation aligns with project philosophy of avoiding unnecessary complexity

3. **Cross-Platform** - Works on Linux, Windows, macOS with single codebase

4. **Production Path** - Start with RocksDB backend (proven stability), migrate to SurrealKV when it reaches 1.0 for enhanced versioning

5. **Embeddable** - Runs in-process, no separate server needed (Principle 2: Autonomy)

**Implementation Strategy:**
- Use SurrealDB embedded mode with RocksDB backend
- Implement immutability patterns at application level
- Leverage Live Queries for reactive actions (solves future problems)
- Export/import primitives will support P2P sync layer (future work)

**Risk Mitigation:**
- SurrealDB is younger than SQLite but v2.0 is production-ready
- RocksDB backend provides battle-tested storage layer
- Active community (30k+ GitHub stars) reduces abandonment risk
- Can migrate to redb if critical issues found during prototyping

**Next Steps:**
1. Build proof-of-concept with Transaction entity (1-2 days)
2. Validate Live Queries work as expected for reactive features
3. Benchmark performance against success criteria
4. Document integration patterns for team
