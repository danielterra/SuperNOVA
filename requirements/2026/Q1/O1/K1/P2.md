## Problem 2: Technology Stack Selection

### What
We don't know which technology stack to use for building SuperNOVA that needs to:
- Support cross-platform desktop (Linux, Windows, macOS)
- Enable users to create entities and record data through intuitive UI
- Be "as intuitive as a spreadsheet" (Principle 1: Simplicity as Power)
- Run entirely on user's device (Principle 2: Decentralization and Autonomy)
- Support rapid prototyping for Q1 financial tracker use case
- Be open source (Principle 7: Open Source and Collaboration)
- **Have minimal dependencies** - Avoid bringing entire web browsers, JavaScript runtimes, or unnecessary complexity

### Why
The technology stack is fundamental to achieving KR1. Users need to:
- Record 20+ transactions with custom categories in < 30 minutes
- Have an intuitive interface (no training beyond tutorial)
- Use a system that runs locally without servers

Choosing the wrong stack could:
- Block cross-platform delivery
- Make UI development slow or complex
- Create barriers to "Excel-like" simplicity
- Require online connectivity (violates autonomy principle)
- Make the codebase difficult for community contribution
- **Add unnecessary complexity** - Bundling web browsers, JavaScript ecosystems, multiple language runtimes
- **Increase binary size** - Larger downloads, slower startup, more dependencies to maintain
- **Create maintenance burden** - More dependencies = more security updates, breaking changes

### Philosophy: Minimal Dependencies

We explicitly reject solutions that require:
- ❌ **WebView-based frameworks** (Tauri, Dioxus, Electron) - Bring browser engine dependencies
- ❌ **JavaScript/Node.js ecosystem** - Requires npm, bundlers, transpilers, multiple languages
- ❌ **Alternative language runtimes** (Flutter/Dart, .NET) - Adds another runtime to maintain
- ❌ **React/Vue/Svelte** - Adds complex virtual DOM, build toolchains, package ecosystems

We want:
- ✅ **Pure Rust** - Single language, single toolchain (Cargo)
- ✅ **Native rendering** - Direct OS graphics APIs, no browser
- ✅ **Minimal runtime** - Small binary, fast startup, low memory
- ✅ **Direct dependencies only** - Only what we actually need

### How (Hypotheses)

#### Option 1: Slint ⭐ RECOMMENDED

**Architecture:**
- **Language**: Pure Rust
- **UI**: Declarative `.slint` markup language
- **Renderer**: Skia (GPU-accelerated) or software renderer
- **Binary**: <5 MB (runtime <300 KB)

**Why Slint is Best for SuperNOVA:**

1. **Declarative UI - Perfect for Forms**
   - `.slint` markup is designed for structured UIs (forms, tables, grids)
   - "Spreadsheet-like" interfaces are exactly what Slint excels at
   - Reactive property bindings built-in (no manual state management)
   - Example:
   ```slint
   export component TransactionForm {
       in-out property <string> category;
       in-out property <float> amount;

       VerticalLayout {
           Text { text: "New Transaction"; font-size: 18px; }
           LineEdit { text <=> category; placeholder-text: "Category"; }
           SpinBox { value <=> amount; minimum: 0; }
           Button { text: "Save"; clicked => { save_transaction(); } }
       }
   }
   ```

2. **Production-Ready with Real-World Use**
   - Used by: **Schneider Electric**, **Unity**, **JetBrains**, **GitHub**
   - Version 1.x stable (graduated from development)
   - Embedded systems use case proves reliability
   - Desktop support active and improving

3. **Minimal Dependencies**
   - Runtime: **<300 KB** (smallest possible)
   - Total binary: **<5 MB** typical
   - Only dependencies: Skia (or software renderer fallback)
   - Pure Rust - single toolchain

4. **Direct Database Integration**
   - Rust backend connects directly to SurrealDB/redb
   - No IPC, no serialization overhead
   - Business logic and UI in same process
   - Example:
   ```rust
   // Direct database access from UI callbacks
   slint::slint! {
       export component App { /* ... */ }
   }

   let app = App::new();
   let db = Database::open("supernova.db")?;

   app.on_save_transaction(move |amount, category| {
       db.insert_transaction(amount, &category).unwrap();
   });
   ```

5. **Visual Designer Coming (2025)**
   - Drag-and-drop UI designer launching
   - Will accelerate UI development significantly
   - Paid offering but optional (markup still works)

**Advantages for SuperNOVA:**

- ✅ **Perfect fit for structured UI** - Forms, tables, grids (financial tracker UI)
- ✅ **Reactive by design** - Property bindings match our reactive architecture
- ✅ **Tiny footprint** - <300 KB runtime minimizes dependencies
- ✅ **Production-proven** - Major companies using it successfully
- ✅ **Pure Rust** - Single language, direct DB integration
- ✅ **Fast rendering** - Skia GPU acceleration
- ✅ **Free for desktop** - Royalty-free license (no cost)
- ✅ **Learning curve acceptable** - Declarative syntax familiar to anyone who knows HTML/CSS

**Disadvantages:**

- ⚠️ **Learning curve** - `.slint` markup is new (but simple)
- ⚠️ **Desktop "in progress"** - Less mature than embedded use case (but stable enough)
- ⚠️ **Smaller ecosystem** - Fewer pre-built components than web frameworks
- ⚠️ **Less flexible layouts** - Not as powerful as CSS flexbox/grid (but enough for forms)
- ⚠️ **No mobile yet** - iOS/Android in roadmap (not Q1 concern)

**Alignment with Principles:**
- ✅ **Simplicity**: Declarative UI, perfect for structured "spreadsheet-like" interfaces
- ✅ **Autonomy**: Fully local, no network dependencies
- ✅ **Open Source**: GPL for free/open source, Royalty-free license for desktop/web
- ✅ **Minimal Dependencies**: <300 KB runtime, pure Rust

**Example Stack:**
```
Language: Rust
UI: Slint declarative markup
Database: SurrealDB or redb
Build: Cargo only
Binary size: ~5-10 MB
```

**Real-World Slint Code Example:**
```slint
// transaction_form.slint
import { Button, LineEdit, SpinBox, VerticalBox } from "std-widgets.slint";

export component TransactionForm inherits Window {
    in-out property <string> category: "";
    in-out property <float> amount: 0;

    callback save-clicked(string, float);

    VerticalBox {
        padding: 20px;
        spacing: 10px;

        Text {
            text: "Record Transaction";
            font-size: 20px;
            font-weight: 700;
        }

        HorizontalBox {
            Text { text: "Category:"; }
            LineEdit {
                text <=> root.category;
                placeholder-text: "e.g., Food, Transport";
            }
        }

        HorizontalBox {
            Text { text: "Amount:"; }
            SpinBox {
                value <=> root.amount;
                minimum: 0;
                maximum: 999999;
            }
        }

        Button {
            text: "Save Transaction";
            primary: true;
            clicked => {
                root.save-clicked(root.category, root.amount);
                root.category = "";
                root.amount = 0;
            }
        }
    }
}
```

```rust
// main.rs
use slint::Model;

slint::include_modules!();

fn main() {
    let app = TransactionForm::new().unwrap();
    let db = Database::open("supernova.db").unwrap();

    app.on_save_clicked(move |category, amount| {
        // Direct database access - no IPC!
        db.insert_transaction(Transaction {
            category: category.to_string(),
            amount: amount as f64,
            timestamp: SystemTime::now(),
        }).unwrap();

        println!("Saved: {} - ${}", category, amount);
    });

    app.run().unwrap();
}
```

---

#### Option 2: iced or egui (Immediate/Retained Mode Native GUI)

**Architecture:**
- **Language**: Pure Rust
- **UI**: Programmatic (code-based, no markup)
- **Renderer**: wgpu (iced) or custom (egui)
- **Binary**: <5 MB

**iced - Elm-Inspired Reactive Architecture:**

**Why iced Could Work:**

1. **Elm Architecture** - Clean, predictable state management
   ```rust
   struct App {
       amount: f64,
       category: String,
   }

   enum Message {
       AmountChanged(f64),
       CategoryChanged(String),
       SaveClicked,
   }

   impl Application for App {
       fn update(&mut self, message: Message) {
           match message {
               Message::SaveClicked => {
                   // Save to database
               }
               // ...
           }
       }

       fn view(&self) -> Element<Message> {
           column![
               text("Record Transaction").size(20),
               text_input("Category", &self.category)
                   .on_input(Message::CategoryChanged),
               // ...
           ].into()
       }
   }
   ```

2. **Production Use** - System76 using iced for **COSMIC desktop shell**
3. **Mature** - Used in real products, active development
4. **Pure Rust** - Direct database integration

**egui - Immediate Mode GUI:**

**Why egui Could Work:**

1. **Immediate Mode** - Very simple mental model
   ```rust
   egui::CentralPanel::default().show(ctx, |ui| {
       ui.heading("Record Transaction");
       ui.text_edit_singleline(&mut self.category);
       ui.add(egui::DragValue::new(&mut self.amount));
       if ui.button("Save").clicked() {
           // Save to database
       }
   });
   ```

2. **Production Use** - **rerun.io** (data visualization tool), many others
3. **Very Fast Iteration** - Code changes reflect immediately
4. **Minimal Boilerplate** - Less code than iced

**Advantages (iced/egui):**

- ✅ **Pure Rust** - Single language, direct DB integration
- ✅ **Maximum performance** - Native rendering, no browser
- ✅ **Small binaries** - <5 MB typical
- ✅ **Production-ready** - Both used in real products
- ✅ **Full control** - No abstraction layers
- ✅ **Minimal dependencies** - Only what's needed for rendering

**Disadvantages (iced/egui):**

- ⚠️ **Programmatic UI** - More code than declarative (Slint)
- ⚠️ **Steeper learning curve** - Requires understanding architecture patterns
- ⚠️ **More verbose** - Forms take more lines of code
- ⚠️ **Less visual polish** - Harder to achieve refined look (but possible)
- ⚠️ **No designer tool** - All UI is hand-coded
- ⚠️ **Smaller talent pool** - Fewer developers familiar with these frameworks

**Comparison: Slint vs iced vs egui for Forms**

| Aspect | Slint | iced | egui |
|--------|-------|------|------|
| **Lines of code (simple form)** | ~30 | ~80 | ~50 |
| **Visual polish** | Good (Skia) | Good (wgpu) | Basic (immediate) |
| **Learning curve** | Medium | Steep (Elm) | Medium (immediate) |
| **Hot reload** | Yes | Partial | Yes |
| **Designer tool** | Coming 2025 | No | No |
| **Best for** | Forms, tables | Complex apps | Tools, editors |

**Alignment with Principles:**
- ⚠️ **Simplicity**: Harder to achieve "Excel-like" UI quickly (more code required)
- ✅ **Autonomy**: Fully local
- ✅ **Open Source**: MIT/Apache licensed
- ✅ **Minimal Dependencies**: Pure Rust, small binaries

**Example Stack:**
```
Language: Rust
UI: iced (reactive) or egui (immediate)
Database: SurrealDB or redb
Build: Cargo only
Binary size: ~5-10 MB
```

---

### Success Criteria

The chosen stack must demonstrate:

1. **Cross-platform build** - Successfully builds and runs on Linux, Windows, macOS
2. **UI development speed** - Can build transaction entry form in < 4 hours
3. **Database integration** - Clean integration with SurrealDB or redb (no IPC complexity)
4. **Performance baseline** - App starts in < 2 seconds, UI responsive (<16ms frame time)
5. **Binary size** - < 10 MB (reject anything requiring browsers or runtimes)
6. **Minimal dependencies** - Only Rust + essential rendering libraries
7. **UI polish potential** - Can achieve clean, intuitive interface for forms/tables
8. **Community support** - Active development, good documentation, examples

### References

- **Slint**: https://slint.rs/ | https://github.com/slint-ui/slint
- **iced**: https://iced.rs/ | https://github.com/iced-rs/iced
- **egui**: https://github.com/emilk/egui
- **Slint Tutorial**: https://slint.dev/docs/tutorial/rust
- **System76 COSMIC** (iced): https://github.com/pop-os/cosmic-epoch
- **rerun.io** (egui): https://www.rerun.io/

### Philosophy Statement

SuperNOVA's technology choices prioritize **simplicity through minimalism**:

> "The best code is no code. The best dependency is no dependency. We choose tools that do exactly what we need, with nothing extra. A 300 KB runtime is better than a 200 MB browser bundle. Pure Rust is better than JavaScript + Rust + npm + bundlers. Native rendering is better than simulating a browser."

This philosophy guides every technical decision, ensuring SuperNOVA remains:
- **Simple** to understand and contribute to
- **Fast** to build and run
- **Reliable** with fewer moving parts
- **Maintainable** with minimal dependency churn
